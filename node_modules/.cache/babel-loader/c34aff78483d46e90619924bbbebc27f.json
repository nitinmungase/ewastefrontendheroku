{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isIP;\n\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n11.3.  Examples\n\n   The following addresses\n\n             fe80::1234 (on the 1st link of the node)\n             ff02::5678 (on the 5th link of the node)\n             ff08::9abc (on the 10th organization of the node)\n\n   would be represented as follows:\n\n             fe80::1234%1\n             ff02::5678%5\n             ff08::9abc%10\n\n   (Here we assume a natural translation from a zone index to the\n   <zone_id> part, where the Nth zone of any scope is translated into\n   \"N\".)\n\n   If we use interface names as <zone_id>, those addresses could also be\n   represented as follows:\n\n            fe80::1234%ne0\n            ff02::5678%pvc1.3\n            ff08::9abc%interface10\n\n   where the interface \"ne0\" belongs to the 1st link, \"pvc1.3\" belongs\n   to the 5th link, and \"interface10\" belongs to the 10th organization.\n * * */\n\n\nvar ipv4Maybe = /^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/;\nvar ipv6Block = /^[0-9A-F]{1,4}$/i;\n\nfunction isIP(str) {\n  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  (0, _assertString.default)(str);\n  version = String(version);\n\n  if (!version) {\n    return isIP(str, 4) || isIP(str, 6);\n  } else if (version === '4') {\n    if (!ipv4Maybe.test(str)) {\n      return false;\n    }\n\n    var parts = str.split('.').sort(function (a, b) {\n      return a - b;\n    });\n    return parts[3] <= 255;\n  } else if (version === '6') {\n    var addressAndZone = [str]; // ipv6 addresses could have scoped architecture\n    // according to https://tools.ietf.org/html/rfc4007#section-11\n\n    if (str.includes('%')) {\n      addressAndZone = str.split('%');\n\n      if (addressAndZone.length !== 2) {\n        // it must be just two parts\n        return false;\n      }\n\n      if (!addressAndZone[0].includes(':')) {\n        // the first part must be the address\n        return false;\n      }\n\n      if (addressAndZone[1] === '') {\n        // the second part must not be empty\n        return false;\n      }\n    }\n\n    var blocks = addressAndZone[0].split(':');\n    var foundOmissionBlock = false; // marker to indicate ::\n    // At least some OS accept the last 32 bits of an IPv6 address\n    // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says\n    // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,\n    // and '::a.b.c.d' is deprecated, but also valid.\n\n    var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);\n    var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;\n\n    if (blocks.length > expectedNumberOfBlocks) {\n      return false;\n    } // initial or final ::\n\n\n    if (str === '::') {\n      return true;\n    } else if (str.substr(0, 2) === '::') {\n      blocks.shift();\n      blocks.shift();\n      foundOmissionBlock = true;\n    } else if (str.substr(str.length - 2) === '::') {\n      blocks.pop();\n      blocks.pop();\n      foundOmissionBlock = true;\n    }\n\n    for (var i = 0; i < blocks.length; ++i) {\n      // test for a :: which can not be at the string start/end\n      // since those cases have been handled above\n      if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {\n        if (foundOmissionBlock) {\n          return false; // multiple :: in address\n        }\n\n        foundOmissionBlock = true;\n      } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {// it has been checked before that the last\n        // block is a valid IPv4 address\n      } else if (!ipv6Block.test(blocks[i])) {\n        return false;\n      }\n    }\n\n    if (foundOmissionBlock) {\n      return blocks.length >= 1;\n    }\n\n    return blocks.length === expectedNumberOfBlocks;\n  }\n\n  return false;\n}\n\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","isIP","_assertString","_interopRequireDefault","require","obj","__esModule","ipv4Maybe","ipv6Block","str","version","arguments","length","undefined","String","test","parts","split","sort","a","b","addressAndZone","includes","blocks","foundOmissionBlock","foundIPv4TransitionBlock","expectedNumberOfBlocks","substr","shift","pop","i","module"],"sources":["C:/Users/Ni3/Desktop/C DAC/Project/React/react-jwt-auth-master/node_modules/validator/lib/isIP.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isIP;\n\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n11.3.  Examples\n\n   The following addresses\n\n             fe80::1234 (on the 1st link of the node)\n             ff02::5678 (on the 5th link of the node)\n             ff08::9abc (on the 10th organization of the node)\n\n   would be represented as follows:\n\n             fe80::1234%1\n             ff02::5678%5\n             ff08::9abc%10\n\n   (Here we assume a natural translation from a zone index to the\n   <zone_id> part, where the Nth zone of any scope is translated into\n   \"N\".)\n\n   If we use interface names as <zone_id>, those addresses could also be\n   represented as follows:\n\n            fe80::1234%ne0\n            ff02::5678%pvc1.3\n            ff08::9abc%interface10\n\n   where the interface \"ne0\" belongs to the 1st link, \"pvc1.3\" belongs\n   to the 5th link, and \"interface10\" belongs to the 10th organization.\n * * */\nvar ipv4Maybe = /^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/;\nvar ipv6Block = /^[0-9A-F]{1,4}$/i;\n\nfunction isIP(str) {\n  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  (0, _assertString.default)(str);\n  version = String(version);\n\n  if (!version) {\n    return isIP(str, 4) || isIP(str, 6);\n  } else if (version === '4') {\n    if (!ipv4Maybe.test(str)) {\n      return false;\n    }\n\n    var parts = str.split('.').sort(function (a, b) {\n      return a - b;\n    });\n    return parts[3] <= 255;\n  } else if (version === '6') {\n    var addressAndZone = [str]; // ipv6 addresses could have scoped architecture\n    // according to https://tools.ietf.org/html/rfc4007#section-11\n\n    if (str.includes('%')) {\n      addressAndZone = str.split('%');\n\n      if (addressAndZone.length !== 2) {\n        // it must be just two parts\n        return false;\n      }\n\n      if (!addressAndZone[0].includes(':')) {\n        // the first part must be the address\n        return false;\n      }\n\n      if (addressAndZone[1] === '') {\n        // the second part must not be empty\n        return false;\n      }\n    }\n\n    var blocks = addressAndZone[0].split(':');\n    var foundOmissionBlock = false; // marker to indicate ::\n    // At least some OS accept the last 32 bits of an IPv6 address\n    // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says\n    // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,\n    // and '::a.b.c.d' is deprecated, but also valid.\n\n    var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);\n    var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;\n\n    if (blocks.length > expectedNumberOfBlocks) {\n      return false;\n    } // initial or final ::\n\n\n    if (str === '::') {\n      return true;\n    } else if (str.substr(0, 2) === '::') {\n      blocks.shift();\n      blocks.shift();\n      foundOmissionBlock = true;\n    } else if (str.substr(str.length - 2) === '::') {\n      blocks.pop();\n      blocks.pop();\n      foundOmissionBlock = true;\n    }\n\n    for (var i = 0; i < blocks.length; ++i) {\n      // test for a :: which can not be at the string start/end\n      // since those cases have been handled above\n      if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {\n        if (foundOmissionBlock) {\n          return false; // multiple :: in address\n        }\n\n        foundOmissionBlock = true;\n      } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {// it has been checked before that the last\n        // block is a valid IPv4 address\n      } else if (!ipv6Block.test(blocks[i])) {\n        return false;\n      }\n    }\n\n    if (foundOmissionBlock) {\n      return blocks.length >= 1;\n    }\n\n    return blocks.length === expectedNumberOfBlocks;\n  }\n\n  return false;\n}\n\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}